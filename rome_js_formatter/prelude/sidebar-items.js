initSidebarItems({"constant":[["LINE_TERMINATORS",""]],"enum":[["FormatElement","Language agnostic IR for formatting source code."],["FormatError","Series of errors encountered during formatting"],["LineMode",""],["PrintMode",""],["Token","See [crate::builders::token] for documentation"],["TrailingSeparator",""],["VerbatimKind",""]],"fn":[["block_indent","Inserts a hard line break before and after the content and increases the indention level for the content by one."],["comment","Marks some content as a comment trivia."],["dynamic_token","Create a token from a dynamic string and a range of the input source"],["empty_line","A forced empty line. An empty line inserts enough line breaks in the output for the previous and next element to be separated by an empty line."],["expand_parent","IR element that forces the parent group to print in expanded mode."],["format","The `format` function takes an [`Arguments`] struct and returns the resulting formatting IR."],["format_delimited","Formats a group delimited by an opening and closing token, such as a function body delimited by ‘{’ and ‘}’ tokens"],["format_inserted",""],["format_inserted_close_paren",""],["format_inserted_open_paren",""],["format_leading_trivia","Formats the leading trivia (comments, skipped token trivia) of a token"],["format_once","Creates an inline `Format` object that can only be formatted once."],["format_only_if_breaks","Formats the given token only if the group does break and otherwise retains the token’s trivia."],["format_or_verbatim","Formats a node using its [`AsFormat`] implementation but falls back to printing the node as it is in the source document if the formatting returns an [`FormatError`]."],["format_parenthesize","Adds parentheses around some content Ensures that the leading trivia of the `first_content_token` is moved before the opening parentheses and the trailing trivia of the `last_content_token` is moved after the closing parentheses."],["format_removed","Formats the leading and trailing trivia of a removed token."],["format_replaced","Print out a `token` from the original source with a different `content`."],["format_suppressed_node","Format a node having formatter suppression comment applied to it"],["format_trailing_trivia","Formats the trailing trivia (comments) of a token"],["format_trimmed_token","! Provides builders for working with tokens and the tokens trivia Formats a token without its leading or trailing trivia"],["format_unknown_node","Formats unknown nodes. The difference between this method  and `format_verbatim` is that this method doesn’t track nodes/tokens as [FormatElement::Verbatim]. They are just printed as they are."],["format_verbatim_node","“Formats” a node according to its original formatting in the source text. Being able to format a node “as is” is useful if a node contains syntax errors. Formatting a node with syntax errors has the risk that Rome misinterprets the structure of the code and formatting it could “mess up” the developers, yet incomplete, work or accidentally introduce new syntax errors."],["format_with","Creates an object implementing `Format` that calls the passed closure to perform the formatting."],["get_lines_before","Get the number of line breaks between two consecutive SyntaxNodes in the tree"],["group_elements","Creates a logical `Group` around the content that should either consistently be printed on a single line or broken across multiple lines."],["hard_line_break","A forced line break that are always printed. A hard line break forces any enclosing `Group` to be printed over multiple lines."],["if_group_breaks","Adds a conditional content that is emitted only if it isn’t inside an enclosing `Group` that is printed on a single line. The element allows, for example, to insert a trailing comma after the last array element only if the array doesn’t fit on a single line."],["if_group_fits_on_line","Adds a conditional content specific for `Group`s that fit on a single line. The content isn’t emitted for `Group`s spanning multiple lines."],["indent","It adds a level of indentation to the given content"],["labelled","Marks some content with a label."],["line_suffix","Pushes some content to the end of the current line"],["line_suffix_boundary","Inserts a boundary for line suffixes that forces the printer to print all pending line suffixes. Helpful if a line sufix shouldn’t pass a certain point."],["normalize_newlines","Replace the line terminators matching the provided list with “\\n” since its the only line break type supported by the printer"],["soft_block_indent","Indents the content by inserting a line break before and after the content and increasing the indention level for the content by one if the enclosing group doesn’t fit on a single line. Doesn’t change the formatting if the enclosing group fits on a single line."],["soft_line_break","A line break that only gets printed if the enclosing `Group` doesn’t fit on a single line. It’s omitted if the enclosing `Group` fits on a single line. A soft line break is identical to a hard line break when not enclosed inside of a `Group`."],["soft_line_break_or_space","A line break if the enclosing `Group` doesn’t fit on a single line, a space otherwise."],["soft_line_indent_or_space","If the enclosing `Group` doesn’t fit on a single line, inserts a line break and indent. Otherwise, just inserts a space."],["space_token","Inserts a single space. Allows to separate different tokens."],["syntax_token_cow_slice","String that is the same as in the input source text if `text` is [`Cow::Borrowed`] or some replaced content if `text` is [`Cow::Owned`]."],["syntax_token_text_slice","Copies a source text 1:1 into the output text."],["token","Creates a token that gets written as is to the output. Make sure to properly escape the text if it’s user generated (e.g. a string and not a language keyword)."],["write","The `write` function takes a target buffer and an `Arguments` struct that can be precompiled with the `format_args!` macro."]],"macro":[["best_fitting","Provides multiple different alternatives and the printer picks the first one that fits. Use this as last resort because it requires that the printer must try all variants in the worst case. The passed variants must be in the following order:"],["dbg_write","Writes formatted data into the given buffer and prints all written elements for a quick and dirty debugging."],["format","Creates the Format IR for a value."],["format_args","Constructs the parameters for other formatting macros."],["write","Writes formatted data into a buffer."]],"struct":[["BlockIndent",""],["ConditionalGroupContent",""],["DynamicToken",""],["ExpandParent",""],["Fill","Fill is a list of [FormatElement]s along with a separator."],["FillBuilder","Builder to fill as many elements as possible on a single line."],["FormatComment",""],["FormatLabelled",""],["FormatOnce",""],["FormatSeparatedOptions",""],["FormatWith","Utility for formatting some content with an inline lambda function."],["Formatter","Handles the formatting of a CST and stores the context how the CST should be formatted (user preferences). The formatter is passed to the [Format] implementation of every node in the CST so that they can use it to format their children."],["Group","Group is a special token that controls how the child tokens are printed."],["GroupElements",""],["IfGroupBreaks",""],["Indent",""],["Interned",""],["JoinBuilder","Builder to join together a sequence of content. See [Formatter::join]"],["JoinNodesBuilder","Builder to join together nodes that ensures that nodes separated by empty lines continue to be separated by empty lines in the formatted output."],["Label",""],["LabelId",""],["Line",""],["LineSuffix",""],["LineSuffixBoundary",""],["List","A token used to gather a list of elements; see [crate::Formatter::join_with]."],["PrinterOptions","Options that affect how the [crate::Printer] prints the format tokens"],["SimpleFormatContext",""],["Space",""],["StaticToken",""],["SyntaxTokenCowSlice",""],["SyntaxTokenTextSlice",""],["Verbatim","Information of the node/token formatted verbatim"]],"trait":[["BufferExtensions",""],["Format","Formatting trait for types that can create a formatted representation. The `rome_formatter` equivalent to [std::fmt::Display]."],["FormatAstSeparatedListExtension","AST Separated list formatting extension methods"],["FormatRule","Rule that knows how to format an object of type `T`."],["MemoizeFormat","Utility trait that allows memorizing the output of a [Format]. Useful to avoid re-formatting the same object twice."],["_","Utility trait used to simplify the formatting of optional objects that are formattable."]],"type":[["FormatResult","Public return type of the formatter"]]});